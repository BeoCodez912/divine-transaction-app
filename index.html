<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Divine Transaction Manifestation</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
  <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
  <style>
    body { 
      font-family:'Segoe UI',sans-serif; 
      background:linear-gradient(135deg,#0f0c29,#302b63,#24243e); 
      color:#fff; 
      margin:0; 
      padding:20px; 
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container { 
      max-width:960px; 
      margin:auto; 
      background:rgba(0,0,0,.45); 
      padding:2rem; 
      border-radius:16px; 
      border:1px solid gold; 
      box-shadow:0 0 15px rgba(255,215,0,.5); 
    }
    h1 { text-align:center; color:gold; margin:0 0 8px; }
    .subtitle { text-align:center; color:#ccc; margin:0 0 22px; }
    .input-row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:16px; }
    input, select { padding:10px; border-radius:8px; border:none; flex:1 1 220px; }
    button { background:gold; color:#0f0c29; padding:10px 16px; border:none; border-radius:8px; cursor:pointer; font-weight:700; }
    button:hover { filter:brightness(1.06); }
    #tonConnectButton { margin:0 0 14px; display:flex; justify-content:center; }
    .scripture,.log { background:rgba(255,255,255,.08); padding:1rem; border-radius:10px; margin-top:16px; }
    #logArea { 
      position: fixed; 
      bottom: 20px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(255,215,0,.97); 
      color: #0f0c29; 
      padding: 10px 20px; 
      border-radius: 30px; 
      font-size: 14px; 
      z-index: 9999; 
      max-width: 92%; 
      display: none;
      text-align: center;
    }
    .loading { color: gold; }
    .error { color: #ff6b6b; }
    .success { color: #51cf66; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Divine Transaction Manifestation</h1>
    <p class="subtitle">Divide your last on-chain transfer and bless multiple recipients across ETH, Polygon, or TON.</p>

    <div id="tonConnectButton"></div>

    <div class="input-row">
      <input id="amountInput" placeholder="Divisor (e.g. 2 to divide last tx by 2)"/>
      <input id="toInput" placeholder="Recipients (comma-separated addresses)"/>
      <select id="chainSelect">
        <option value="ethereum">Ethereum</option>
        <option value="polygon">Polygon</option>
        <option value="ton">TON</option>
      </select>
    </div>

    <div class="input-row">
      <button onclick="connectWallet()">Connect</button>
      <button onclick="disconnectWallet()">Disconnect</button>
      <button onclick="fetchLastTxValue()">Fetch Last Tx</button>
      <button onclick="sendBlessings()">Send Blessings</button>
    </div>

    <div class="scripture">
      <p><strong>Matthew 5:11-12</strong> — Blessed are ye, when men shall revile you… rejoice, and be exceeding glad.</p>
      <p><strong>John 1:1-5</strong> — In the beginning was the Word, and the Word was with God, and the Word was God…</p>
    </div>

    <div class="log" id="localLog"></div>
  </div>

  <div id="logArea"></div>

<script>
// Free API keys that should work
const ETHERSCAN_KEY = "YourApiKeyToken"; // Free tier - no key needed for basic usage
const POLYGONSCAN_KEY = "YourApiKeyToken"; // Free tier - no key needed for basic usage

let provider, signer, userAddress = null;
let lastTxValueWei = 0n;
let tonUI = null;

function showPopup(msg, type = "info") {
  const el = document.getElementById("logArea");
  el.textContent = msg;
  el.style.display = "block";
  
  // Remove previous classes
  el.classList.remove("loading", "error", "success");
  
  // Add appropriate class
  if (type === "error") el.classList.add("error");
  else if (type === "success") el.classList.add("success");
  else if (type === "loading") el.classList.add("loading");
  
  setTimeout(() => {
    el.style.display = "none";
    el.classList.remove("loading", "error", "success");
  }, 7000);
  
  // Also log to local log area
  logToScreen(msg, type);
}

function logToScreen(msg, type = "info") {
  const logArea = document.getElementById("localLog");
  const timestamp = new Date().toLocaleTimeString();
  const color = type === "error" ? "#ff6b6b" : type === "success" ? "#51cf66" : "#ffd700";
  logArea.innerHTML += `<div style="color:${color}; margin:5px 0; font-size:14px;">[${timestamp}] ${msg}</div>`;
  logArea.scrollTop = logArea.scrollHeight;
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// Initialize TON Connect with proper error handling
window.addEventListener("DOMContentLoaded", async () => {
  try {
    tonUI = new TON_CONNECT_UI.TonConnectUI({
      manifestUrl: window.location.href.replace(/\/$/, '') + '/tonconnect-manifest.json',
      buttonRootId: "tonConnectButton"
    });

    // Try to restore connection
    await tonUI.restoreConnection();
    
    tonUI.onStatusChange((wallet) => {
      if (wallet && wallet.account?.address) {
        userAddress = wallet.account.address;
        showPopup("TON wallet connected successfully!", "success");
        logToScreen(`TON Connected: ${userAddress}`, "success");
      } else {
        userAddress = null;
        logToScreen("TON wallet disconnected", "info");
      }
    });
    
    logToScreen("TON Connect initialized successfully", "success");
  } catch (error) {
    console.error("TON Connect initialization error:", error);
    logToScreen("TON Connect initialization failed: " + error.message, "error");
  }
});

async function connectWallet() {
  const chain = document.getElementById("chainSelect").value;

  if (chain === "ton") {
    if (!tonUI) {
      showPopup("TON Connect UI not ready. Please refresh the page.", "error");
      return;
    }
    try {
      await tonUI.connectWallet();
      showPopup("Connecting to TON wallet...", "loading");
    } catch (error) {
      showPopup("TON connection failed: " + error.message, "error");
    }
    return;
  }

  // EVM chains (Ethereum/Polygon)
  if (!window.ethereum) {
    showPopup("MetaMask not found. Please install MetaMask.", "error");
    return;
  }

  try {
    showPopup("Connecting to MetaMask...", "loading");
    provider = new ethers.BrowserProvider(window.ethereum);
    const accounts = await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();
    
    // Get chain ID to verify correct network
    const network = await provider.getNetwork();
    const expectedChainId = chain === "polygon" ? 137n : 1n;
    
    if (network.chainId !== expectedChainId) {
      showPopup(`Please switch to ${chain === "polygon" ? "Polygon" : "Ethereum"} Mainnet`, "error");
      userAddress = null;
      return;
    }
    
    showPopup(`Connected to ${chain}: ${userAddress.slice(0, 8)}...`, "success");
    logToScreen(`Connected to ${chain}: ${userAddress}`, "success");
  } catch (error) {
    showPopup("Connection failed: " + error.message, "error");
  }
}

function disconnectWallet() {
  const chain = document.getElementById("chainSelect").value;
  
  if (chain === "ton" && tonUI) {
    tonUI.disconnect();
  }
  
  provider = null;
  signer = null;
  userAddress = null;
  showPopup("Disconnected from wallet", "info");
}

async function fetchLastTxValue() {
  if (!userAddress) {
    showPopup("Please connect your wallet first", "error");
    return;
  }

  const chain = document.getElementById("chainSelect").value;
  showPopup(`Fetching last transaction on ${chain}...`, "loading");

  if (chain === "ton") {
    try {
      // Using public TON API without key
      const url = `https://tonapi.io/v2/blockchain/accounts/${userAddress}/transactions?limit=10`;
      const res = await fetch(url);
      
      if (!res.ok) throw new Error(`API error: ${res.status}`);
      
      const json = await res.json();
      const transactions = Array.isArray(json?.transactions) ? json.transactions : [];
      
      // Find the most recent outgoing transaction
      let lastTx = null;
      for (const tx of transactions) {
        if (Array.isArray(tx.out_msgs) && tx.out_msgs.length > 0) {
          lastTx = tx;
          break;
        }
        if (tx.in_msg && tx.in_msg.source && tx.in_msg.source !== userAddress) {
          lastTx = tx;
          break;
        }
      }
      
      if (!lastTx) {
        showPopup("No recent transactions found", "error");
        return;
      }

      // Calculate value
      let txValue = 0n;
      if (Array.isArray(lastTx.out_msgs)) {
        for (const msg of lastTx.out_msgs) {
          txValue += BigInt(msg.value || 0);
        }
      }
      if (txValue === 0n && lastTx.in_msg) {
        txValue = BigInt(lastTx.in_msg.value || 0);
      }

      lastTxValueWei = txValue;

      if (lastTxValueWei === 0n) {
        showPopup("Last transaction value is 0", "error");
      } else {
        const tonAmount = Number(lastTxValueWei) / 1e9;
        showPopup(`Last TON transaction: ${tonAmount.toFixed(4)} TON`, "success");
        logToScreen(`Fetched TON tx: ${tonAmount.toFixed(4)} TON`, "success");
      }
    } catch (error) {
      console.error("TON fetch error:", error);
      showPopup("Failed to fetch TON transactions: " + error.message, "error");
    }
    return;
  }

  // EVM chains
  try {
    const network = chain === "polygon" ? "matic" : "homestead";
    
    // Use ethers provider without API key for basic functionality
    const provider = new ethers.JsonRpcProvider(
      chain === "polygon" 
        ? "https://polygon-rpc.com" 
        : "https://eth.llamarpc.com"
    );

    const history = await provider.getHistory(userAddress);
    
    // Find most recent outgoing transaction with value
    const tx = [...history]
      .reverse()
      .find(t => t.from.toLowerCase() === userAddress.toLowerCase() && t.value > 0n);

    if (tx) {
      lastTxValueWei = tx.value;
      const amount = ethers.formatEther(lastTxValueWei);
      const symbol = chain === "polygon" ? "MATIC" : "ETH";
      showPopup(`Last transaction: ${amount} ${symbol}`, "success");
      logToScreen(`Fetched ${chain} tx: ${amount} ${symbol}`, "success");
    } else {
      showPopup("No outgoing transactions with value found", "error");
    }
  } catch (error) {
    console.error("EVM fetch error:", error);
    showPopup("Failed to fetch transactions: " + error.message, "error");
  }
}

async function sendBlessings() {
  if (!lastTxValueWei || lastTxValueWei === 0n) {
    showPopup("Please fetch a valid transaction first", "error");
    return;
  }

  const divisorStr = document.getElementById("amountInput").value.trim();
  const recipients = document.getElementById("toInput").value.split(",").map(s => s.trim()).filter(Boolean);

  if (!divisorStr || isNaN(divisorStr) || BigInt(divisorStr) <= 0n) {
    showPopup("Please enter a valid divisor number", "error");
    return;
  }
  
  if (recipients.length === 0) {
    showPopup("Please enter at least one recipient address", "error");
    return;
  }

  const divisor = BigInt(divisorStr);
  const divided = lastTxValueWei / divisor;
  const valuePer = divided / BigInt(recipients.length);

  if (valuePer <= 0n) {
    showPopup("Divided amount is too small", "error");
    return;
  }

  const chain = document.getElementById("chainSelect").value;
  showPopup(`Sending blessings to ${recipients.length} recipients...`, "loading");

  if (chain === "ton") {
    for (const to of recipients) {
      try {
        // Validate TON address format
        if (!to.match(/^[EU][Q\d][A-HJ-NP-Za-km-z1-9]{48}$/)) {
          showPopup(`Invalid TON address: ${to}`, "error");
          continue;
        }

        const result = await tonUI.sendTransaction({
          messages: [
            {
              address: to,
              amount: valuePer.toString()
            }
          ]
        });
        
        const tonAmount = Number(valuePer) / 1e9;
        showPopup(`Sent ${tonAmount.toFixed(6)} TON to ${to.slice(0, 8)}...`, "success");
        logToScreen(`Sent to ${to}: ${tonAmount.toFixed(6)} TON`, "success");
        await sleep(2000); // Wait between transactions
      } catch (error) {
        showPopup(`Failed to send to ${to.slice(0, 8)}...: ${error.message}`, "error");
        logToScreen(`Failed to send to ${to}: ${error.message}`, "error");
      }
    }
    return;
  }

  // EVM chains
  for (const to of recipients) {
    try {
      // Validate EVM address format
      if (!to.match(/^0x[a-fA-F0-9]{40}$/)) {
        showPopup(`Invalid ${chain} address: ${to}`, "error");
        continue;
      }

      const tx = await signer.sendTransaction({ 
        to: to, 
        value: valuePer.toString(),
        gasLimit: 21000 // Standard transfer gas limit
      });
      
      showPopup(`Transaction sent to ${to.slice(0, 8)}...`, "loading");
      const receipt = await tx.wait();
      
      const amount = ethers.formatEther(valuePer);
      const symbol = chain === "polygon" ? "MATIC" : "ETH";
      showPopup(`Sent ${amount} ${symbol} to ${to.slice(0, 8)}...`, "success");
      logToScreen(`Sent to ${to}: ${amount} ${symbol} (TX: ${tx.hash})`, "success");
      await sleep(2000); // Wait between transactions
    } catch (error) {
      showPopup(`Failed to send to ${to.slice(0, 8)}...: ${error.message}`, "error");
      logToScreen(`Failed to send to ${to}: ${error.message}`, "error");
    }
  }
}
</script>
</body>
</html>
