<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Divine Transaction Manifestation</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
  <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
  <style>
    body { 
      font-family:'Segoe UI',sans-serif; 
      background:linear-gradient(135deg,#0f0c29,#302b63,#24243e); 
      color:#fff; 
      margin:0; 
      padding:20px; 
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container { 
      max-width:960px; 
      margin:auto; 
      background:rgba(0,0,0,.45); 
      padding:2rem; 
      border-radius:16px; 
      border:1px solid gold; 
      box-shadow:0 0 15px rgba(255,215,0,.5); 
    }
    h1 { text-align:center; color:gold; margin:0 0 8px; }
    .subtitle { text-align:center; color:#ccc; margin:0 0 22px; }
    .input-row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:16px; }
    input, select { padding:10px; border-radius:8px; border:none; flex:1 1 220px; }
    button { background:gold; color:#0f0c29; padding:10px 16px; border:none; border-radius:8px; cursor:pointer; font-weight:700; margin:2px; }
    button:hover { filter:brightness(1.06); }
    button:disabled { background:#666; cursor:not-allowed; }
    #tonConnectButton { margin:0 0 14px; display:flex; justify-content:center; }
    .scripture,.log { background:rgba(255,255,255,.08); padding:1rem; border-radius:10px; margin-top:16px; }
    #logArea { 
      position: fixed; 
      bottom: 20px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(255,215,0,.97); 
      color: #0f0c29; 
      padding: 10px 20px; 
      border-radius: 30px; 
      font-size: 14px; 
      z-index: 9999; 
      max-width: 92%; 
      display: none;
      text-align: center;
    }
    .debug { font-size: 12px; color: #ccc; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Divine Transaction Manifestation</h1>
    <p class="subtitle">Divide your last on-chain transfer and bless multiple recipients across ETH, Polygon, or TON.</p>

    <div id="tonConnectButton"></div>

    <div class="input-row">
      <input id="amountInput" placeholder="Divisor (e.g., 2 to divide last tx by 2)"/>
      <input id="toInput" placeholder="Recipients (comma-separated addresses)"/>
      <select id="chainSelect">
        <option value="ethereum">Ethereum</option>
        <option value="polygon">Polygon</option>
        <option value="ton">TON</option>
      </select>
    </div>

    <div class="input-row">
      <button onclick="connectWallet()" id="connectBtn">Connect</button>
      <button onclick="disconnectWallet()">Disconnect</button>
      <button onclick="fetchLastTxValue()" id="fetchBtn">Fetch Last Tx</button>
      <button onclick="sendBlessings()" id="sendBtn">Send Blessings</button>
      <button onclick="debugConnection()" style="background:#666;">Debug</button>
    </div>

    <div class="scripture">
      <p><strong>Matthew 5:11-12</strong> — Blessed are ye, when men shall revile you… rejoice, and be exceeding glad.</p>
      <p><strong>John 1:1-5</strong> — In the beginning was the Word, and the Word was with God, and the Word was God…</p>
    </div>

    <div class="log" id="localLog">
      <div>Log will appear here...</div>
    </div>
    
    <div class="debug" id="debugInfo"></div>
  </div>

  <div id="logArea"></div>

<script>
// Configuration
const ETHERSCAN_KEY = "YourApiKeyToken";
const POLYGONSCAN_KEY = "YourApiKeyToken";

let provider = null;
let signer = null;
let userAddress = null;
let lastTxValueWei = 0n;
let tonUI = null;

// DOM elements
let connectBtn, fetchBtn, sendBtn, chainSelect, debugInfo;

function showPopup(msg, type = "info") {
  const el = document.getElementById("logArea");
  el.textContent = msg;
  el.style.display = "block";
  
  // Add type-based styling
  el.style.background = type === "error" ? "rgba(255,107,107,0.97)" : 
                         type === "success" ? "rgba(81,207,102,0.97)" : 
                         type === "loading" ? "rgba(255,215,0,0.97)" : "rgba(255,215,0,0.97)";
  
  setTimeout(() => el.style.display = "none", 5000);
  logToScreen(msg, type);
}

function logToScreen(msg, type = "info") {
  const logArea = document.getElementById("localLog");
  const timestamp = new Date().toLocaleTimeString();
  const color = type === "error" ? "#ff6b6b" : 
                type === "success" ? "#51cf66" : 
                type === "loading" ? "#ffd700" : "#ffffff";
  
  if (logArea.innerHTML.includes("Log will appear here...")) {
    logArea.innerHTML = '';
  }
  
  logArea.innerHTML += `<div style="color:${color}; margin:5px 0; font-size:14px;">[${timestamp}] ${msg}</div>`;
  logArea.scrollTop = logArea.scrollHeight;
}

function updateButtonStates() {
  const isConnected = !!userAddress;
  const hasLastTx = lastTxValueWei > 0n;
  
  if (connectBtn) connectBtn.textContent = isConnected ? "Connected" : "Connect";
  if (fetchBtn) fetchBtn.disabled = !isConnected;
  if (sendBtn) sendBtn.disabled = !(isConnected && hasLastTx);
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// Initialize when DOM is loaded
window.addEventListener("DOMContentLoaded", async () => {
  // Get DOM elements
  connectBtn = document.getElementById("connectBtn");
  fetchBtn = document.getElementById("fetchBtn");
  sendBtn = document.getElementById("sendBtn");
  chainSelect = document.getElementById("chainSelect");
  debugInfo = document.getElementById("debugInfo");
  
  try {
    // Initialize TON Connect
    const manifestUrl = new URL('tonconnect-manifest.json', window.location.href).href;
    
    tonUI = new TON_CONNECT_UI.TonConnectUI({
      manifestUrl: manifestUrl,
      buttonRootId: "tonConnectButton"
    });

    // Restore any existing connection
    await tonUI.restoreConnection();
    
    // Handle wallet status changes
    tonUI.onStatusChange((wallet) => {
      if (wallet && wallet.account?.address) {
        userAddress = wallet.account.address;
        showPopup("✓ TON wallet connected", "success");
        logToScreen(`TON wallet connected: ${userAddress}`, "success");
      } else {
        userAddress = null;
        logToScreen("TON wallet disconnected", "info");
      }
      updateButtonStates();
    });
    
    logToScreen("TON Connect initialized successfully", "success");
    debugInfo.innerHTML = `TON Connect: Ready | URL: ${manifestUrl}`;
    
  } catch (error) {
    console.error("TON Connect initialization error:", error);
    logToScreen(`TON Connect init failed: ${error.message}`, "error");
    debugInfo.innerHTML = `TON Connect: Failed - ${error.message}`;
  }
  
  updateButtonStates();
});

async function connectWallet() {
  const chain = chainSelect.value;
  logToScreen(`Connecting to ${chain}...`, "loading");

  if (chain === "ton") {
    if (!tonUI) {
      showPopup("TON Connect not initialized", "error");
      return;
    }
    try {
      await tonUI.connectWallet();
      showPopup("Opening TON wallet...", "loading");
    } catch (error) {
      showPopup(`TON connection failed: ${error.message}`, "error");
    }
    return;
  }

  // EVM chains
  if (!window.ethereum) {
    showPopup("Please install MetaMask", "error");
    return;
  }

  try {
    showPopup("Connecting to MetaMask...", "loading");
    provider = new ethers.BrowserProvider(window.ethereum);
    const accounts = await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    userAddress = await signer.getAddress();
    
    // Verify network
    const network = await provider.getNetwork();
    const expectedChainId = chain === "polygon" ? 137n : 1n;
    
    if (network.chainId !== expectedChainId) {
      showPopup(`Please switch to ${chain === "polygon" ? "Polygon" : "Ethereum"} Mainnet`, "error");
      userAddress = null;
      return;
    }
    
    showPopup(`✓ Connected to ${chain}`, "success");
    logToScreen(`Connected to ${chain}: ${userAddress}`, "success");
    
  } catch (error) {
    showPopup(`Connection failed: ${error.message}`, "error");
    logToScreen(`Connection error: ${error.message}`, "error");
  }
  
  updateButtonStates();
}

function disconnectWallet() {
  const chain = chainSelect.value;
  
  if (chain === "ton" && tonUI) {
    tonUI.disconnect();
  }
  
  provider = null;
  signer = null;
  userAddress = null;
  lastTxValueWei = 0n;
  
  showPopup("Disconnected", "info");
  logToScreen("Wallet disconnected", "info");
  updateButtonStates();
}

async function fetchLastTxValue() {
  if (!userAddress) {
    showPopup("Please connect wallet first", "error");
    return;
  }

  const chain = chainSelect.value;
  showPopup(`Fetching last ${chain} transaction...`, "loading");

  if (chain === "ton") {
    try {
      const url = `https://tonapi.io/v2/blockchain/accounts/${userAddress}/transactions?limit=10`;
      const res = await fetch(url);
      
      if (!res.ok) throw new Error(`TON API error: ${res.status}`);
      
      const json = await res.json();
      const transactions = Array.isArray(json?.transactions) ? json.transactions : [];
      
      // Find most recent transaction with value
      const lastTx = transactions.find(tx => {
        const hasOutgoing = Array.isArray(tx.out_msgs) && tx.out_msgs.some(msg => msg.value > 0);
        const hasIncoming = tx.in_msg && tx.in_msg.value > 0;
        return hasOutgoing || hasIncoming;
      });
      
      if (!lastTx) {
        showPopup("No transactions with value found", "error");
        return;
      }

      // Calculate total value
      let txValue = 0n;
      if (Array.isArray(lastTx.out_msgs)) {
        for (const msg of lastTx.out_msgs) {
          txValue += BigInt(msg.value || 0);
        }
      }
      if (txValue === 0n && lastTx.in_msg) {
        txValue = BigInt(lastTx.in_msg.value || 0);
      }

      lastTxValueWei = txValue;

      if (lastTxValueWei === 0n) {
        showPopup("Transaction value is 0", "error");
      } else {
        const tonAmount = Number(lastTxValueWei) / 1e9;
        showPopup(`✓ Last TON tx: ${tonAmount.toFixed(6)} TON`, "success");
        logToScreen(`Fetched TON transaction: ${tonAmount.toFixed(6)} TON`, "success");
      }
    } catch (error) {
      showPopup(`TON fetch failed: ${error.message}`, "error");
      logToScreen(`TON fetch error: ${error.message}`, "error");
    }
    updateButtonStates();
    return;
  }

  // EVM chains
  try {
    const rpcUrl = chain === "polygon" 
      ? "https://polygon-rpc.com" 
      : "https://eth.llamarpc.com";
    
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    const history = await provider.getHistory(userAddress);
    
    // Find most recent outgoing transaction with value
    const tx = [...history]
      .reverse()
      .find(t => t.from.toLowerCase() === userAddress.toLowerCase() && t.value > 0n);

    if (tx) {
      lastTxValueWei = tx.value;
      const amount = ethers.formatEther(lastTxValueWei);
      const symbol = chain === "polygon" ? "MATIC" : "ETH";
      showPopup(`✓ Last tx: ${amount} ${symbol}`, "success");
      logToScreen(`Fetched ${chain} transaction: ${amount} ${symbol}`, "success");
    } else {
      showPopup("No outgoing transactions found", "error");
    }
  } catch (error) {
    showPopup(`Transaction fetch failed: ${error.message}`, "error");
    logToScreen(`EVM fetch error: ${error.message}`, "error");
  }
  
  updateButtonStates();
}

async function sendBlessings() {
  if (!lastTxValueWei || lastTxValueWei === 0n) {
    showPopup("Fetch a transaction first", "error");
    return;
  }

  const divisorStr = document.getElementById("amountInput").value.trim();
  const recipients = document.getElementById("toInput").value.split(",").map(s => s.trim()).filter(Boolean);

  if (!divisorStr || isNaN(divisorStr) || BigInt(divisorStr) <= 0n) {
    showPopup("Enter a valid divisor", "error");
    return;
  }
  
  if (recipients.length === 0) {
    showPopup("Enter recipient addresses", "error");
    return;
  }

  const divisor = BigInt(divisorStr);
  const divided = lastTxValueWei / divisor;
  const valuePer = divided / BigInt(recipients.length);

  if (valuePer <= 0n) {
    showPopup("Divided amount is too small", "error");
    return;
  }

  const chain = chainSelect.value;
  showPopup(`Sending to ${recipients.length} recipients...`, "loading");

  if (chain === "ton") {
    for (const [index, to] of recipients.entries()) {
      try {
        if (!to.match(/^[EU][Q\d][A-HJ-NP-Za-km-z1-9]{48}$/)) {
          showPopup(`Invalid TON address: ${to}`, "error");
          continue;
        }

        const result = await tonUI.sendTransaction({
          messages: [{ address: to, amount: valuePer.toString() }]
        });
        
        const tonAmount = Number(valuePer) / 1e9;
        showPopup(`✓ Sent ${tonAmount.toFixed(6)} TON (${index + 1}/${recipients.length})`, "success");
        logToScreen(`Sent to ${to}: ${tonAmount.toFixed(6)} TON`, "success");
        await sleep(2000);
      } catch (error) {
        showPopup(`Failed to send to recipient ${index + 1}`, "error");
        logToScreen(`Failed to send to ${to}: ${error.message}`, "error");
      }
    }
    return;
  }

  // EVM chains
  for (const [index, to] of recipients.entries()) {
    try {
      if (!to.match(/^0x[a-fA-F0-9]{40}$/)) {
        showPopup(`Invalid ${chain} address: ${to}`, "error");
        continue;
      }

      const tx = await signer.sendTransaction({ 
        to: to, 
        value: valuePer.toString(),
        gasLimit: 21000
      });
      
      showPopup(`Transaction sent (${index + 1}/${recipients.length})...`, "loading");
      const receipt = await tx.wait();
      
      const amount = ethers.formatEther(valuePer);
      const symbol = chain === "polygon" ? "MATIC" : "ETH";
      showPopup(`✓ Sent ${amount} ${symbol} (${index + 1}/${recipients.length})`, "success");
      logToScreen(`Sent to ${to}: ${amount} ${symbol} (TX: ${tx.hash})`, "success");
      await sleep(2000);
    } catch (error) {
      showPopup(`Failed to send to recipient ${index + 1}`, "error");
      logToScreen(`Failed to send to ${to}: ${error.message}`, "error");
    }
  }
}

function debugConnection() {
  const debugInfo = document.getElementById("debugInfo");
  const info = `
    URL: ${window.location.href}
    User: ${userAddress || "Not connected"}
    TON UI: ${!!tonUI}
    Ethereum: ${!!window.ethereum}
    Last TX: ${lastTxValueWei.toString()}
    Chain: ${chainSelect.value}
  `.split('\n').map(line => line.trim()).filter(line => line);
  
  debugInfo.innerHTML = info.join('<br>');
  logToScreen("Debug information displayed", "info");
}
</script>
</body>
</html>
